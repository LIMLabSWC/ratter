function [obj] = masa_operantobj(a)

% -------- BEGIN Magic code that all protocol objects must have ---
% Default object:
obj = struct('empty', []);
obj = class(obj, mfilename);

% If creating an empty object, return without further ado:
if nargin==1 && strcmp(a, 'empty'), return; end;

delete_sphandle('owner', mfilename); % Delete previous vars owned by this object

% Non-empty: proceed with regular init of this object
if nargin==1 && isstr(a), 
    SoloParamHandle(obj, 'protocol_name', 'value', lower(a)); 
end;

% Make default figure. Remember to make it non-saveable; on next run
% the handle to this figure might be different, and we don't want to
% overwrite it when someone does load_data and some old value of the
% fig handle was stored there...
SoloParamHandle(obj, 'myfig', 'saveable', 0); myfig.value = figure;
SoloFunction('close', 'ro_args', 'myfig');
set(value(myfig), ...
    'Name', value(protocol_name), 'Tag', value(protocol_name), ...
    'closerequestfcn', ['ModuleClose(''' value(protocol_name) ''')'], ...
    'NumberTitle', 'off', 'MenuBar', 'none');

% -------- END Magic code that all protocol objects must have ---

rand('state', sum(100*clock));

screen_size = get(0, 'ScreenSize');
set(value(myfig),'Position',[890 screen_size(4)-700, 210 260]);

SoloParamHandle(obj, 'n_done_trials',    'value', 0);
SoloParamHandle(obj, 'n_started_trials', 'value', 0);
SoloParamHandle(obj, 'maxtrials',        'value', 2000);

SoloParamHandle(obj, 'RealTimeStates', 'value', struct(...
  'wait_for_cpoke',  0, ...  % Waiting for a center poke
  'cpoke',           0, ...
  'cpoke_small',     0, ...
  'cpoke_large',     0, ...
  'short_poke',      0, ...
  'small_available', 0, ...  % Waiting for an answer poke
  'large_available', 0, ...  % Waiting for an answer poke
  'small_reward',    0, ...
  'large_reward',    0, ...
  'time_out1',       0, ...
  'time_out2',       0, ...
  'state35',         0));

x = 1; y = 1;                     % Position on GUI
%[x, y] = InitSaving(obj, x, y);  next_row(y,0.5);
[x, y] = SavingSection(obj, 'init', x, y);

SoloFunction('ParamsSection', 'rw_args', {}, 'ro_args', {});
[x, y, ...
    ValveRightLarge, ValveRightSmall, ValveLeftLarge, ValveLeftSmall, DelayToReward, ...
    TrialLength, RewardAvailPeriod, CinTimeOut] ...
    = ParamsSection(obj, 'init', x, y);

SoloFunction('TrialEvents', 'rw_args', {}, ...
    'ro_args', {'RealTimeStates', 'n_done_trials', 'n_started_trials', 'maxtrials'});
[PokeStretch_history, StateStretch_history, ...
    PokeStretch, StateStretch, AlignOn, ...
    TrialData, CinToTout, LastTrialEvents] = TrialEvents(obj, 'init');

SoloFunction('VpdsSection', 'rw_args',{}, ...
  'ro_args', {'n_done_trials', 'n_started_trials', 'maxtrials'});
[x, y,  VpdList, VpdSmall, VpdLargeMin, VpdLargeMean]= ...
    VpdsSection(obj, 'init', x, y);

SoloFunction('PokeDuration', 'rw_args',{}, ...
  'ro_args', {'n_done_trials', 'n_started_trials', 'maxtrials', ...
  'TrialData', 'VpdList'});
[x, y, BOT, TOP]= PokeDuration(obj, 'init', x, y);

SoloFunction('CurrentTrialPokesSubsection', ...
  'rw_args', {'RealTimeStates'}, ...
  'ro_args', {'n_done_trials','n_started_trials', ...
  'PokeStretch_history', 'StateStretch_history', ...
  'PokeStretch', 'StateStretch', 'AlignOn', 'BOT','TOP'});
[x, y] = CurrentTrialPokesSubsection(obj, 'init', x, y);

SoloFunction('ChordSection', 'rw_args',{}, ...
     'ro_args', {'n_done_trials'});
[x, y] = ChordSection(obj, 'init', x, y);

SoloFunction('BeginnerSection', ...
    'rw_args', {'TrialLength', 'RewardAvailPeriod', 'CinTimeOut', ...
    'VpdSmall', 'VpdLargeMin', 'VpdLargeMean'}, ...
    'ro_args', {'TrialData', 'n_done_trials'});
[x, y, Beginner1, BeginnerTup, C_ReEnter] = ...
    BeginnerSection(obj, 'init', x, y);

% --- Making and uploading the state matrix
SoloFunction('make_and_upload_state_matrix', ...
    'rw_args', 'RealTimeStates', ...
    'ro_args', {'n_done_trials', 'ValveLeftSmall', 'ValveLeftLarge', ...
    'ValveRightSmall', 'ValveRightLarge', ...
    'DelayToReward', 'VpdList'...
    'TrialLength', 'RewardAvailPeriod', 'CinTimeOut', 'CinToTout', ...
    'Beginner1', 'BeginnerTup', 'C_ReEnter'});
make_and_upload_state_matrix(obj, 'init');

push_history(class(obj));
n_started_trials.value = 1;

% ------------------------------------------------------------------
% List of functions to call, in sequence, when a trial is finished:
% If adding a function to this list,
%    (a) Declare its args with a SoloFunction() call
%    (b) Add your function as a method of the current object
%    (c) As the first action of your method, call GetSoloFunctionArgs;
%
SoloParamHandle(obj, 'trial_finished_actions', 'value', { ...
  'TrialEvents(obj, ''get'');'                           ; ...
  'BeginnerSection(obj, ''check_and_change'');'          ; ...
  'ChordSection(obj, ''make_upload'');'                  ; ...
  'ChordSection(obj, ''make_upload_othersounds'');'      ; ...
  'VpdsSection(obj, ''update_vpdlist'');'                ; ...
  'PokeDuration(obj, ''update'');'                       ; ...
  'CurrentTrialPokesSubsection(obj, ''update'');'        ; ...
  'make_and_upload_state_matrix(obj, ''next_matrix'');'  ; ...
  'TrialEvents(obj, ''push_history_then_reset'');'       ; ...
  'push_history(class(obj));'                            ; ... % no args
});

SoloFunction('state35', 'rw_args', {'n_done_trials', 'n_started_trials'}, ...
    'ro_args', 'trial_finished_actions');

% List of functions to call, in sequence, when an update call is made.
% An update call is made every 350 ms:
SoloParamHandle(obj, 'within_trial_update_actions', 'value', { ...
    'TrialEvents(obj, ''get350'');'                      ; ...
    'CurrentTrialPokesSubsection(obj, ''update350'');'   ; ...
    });
SoloFunction('update', 'ro_args', 'within_trial_update_actions');

% ------------------------------------------------------------------

return;