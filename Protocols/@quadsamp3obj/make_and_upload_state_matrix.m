function RealTimeStates = make_and_upload_state_matrix(obj, action)

global left1led; global right1led; global center1led;

DeadTimeReinitPenalty = 0;

GetSoloFunctionArgs;
% SoloFunction('make_and_upload_state_matrix', ...
%    'ro_args', {'n_done_trials', 'side_list', 'vpd_list', ...
%    'chord_sound_len', 'go_dur', 'LegalSkipOut', ...
%    'WaterDelivery', 'RewardPorts', 'DrinkTime', ...
%    'BadBoySound', 'ITISound', 'ITILength', 'ITIReinitPenalty', ...
%    'TimeOutSound', 'TimeOutLength', 'TimeOutReinitPenalty', ...
%    'APokePenalty', ...
%    'ExtraITIonError', 'LeftWValve', 'RightWValve'});


switch action,
    case 'init'
        srate = GetSampleRate(rpbox('getsoundmachine'));

        SoloParamHandle(obj, 'Stateguys', 'value', struct('ITI', [], 'ITIReinit', [], ...
            'ExtraITI', [], 'ExtraITIReinit', [], 'TimeOutFirm', [], 'TimeOut', [], ...
            'TimeOutReinit', []));
        
        amp = 0.003;
        SoloParamHandle(obj, 'white_noise_len',   'value', 2);
        SoloParamHandle(obj, 'white_noise_sound', 'value', ...
            amp*rand(1,floor(white_noise_len*srate)), 'saveable', 0);

        % 150 ms of white noise, followed by 50 ms of silence:
        bb_unit = [amp*rand(1, floor(0.150*srate)) ...
            zeros(1, floor(0.050*srate))];
        SoloParamHandle(obj, 'badboy_sound', 'saveable', 0);
        badboy_sound.value = [bb_unit bb_unit bb_unit bb_unit];

        SoloParamHandle(obj, 'badboy_len', 'value', ...
            length(value(badboy_sound))/floor(srate));

        % Harsher version of badboy sound:
        h_bb_unit = 10*amp*MakeChord( srate, 70-67, 6*1000, 8, 850, 0.005*1000 );
        SoloParamHandle(obj, 'harsher_badboy_sound', 'saveable', 0);
        partial_bb = [amp*rand(1, floor(0.150*srate)) ...
                      zeros(1, floor(0.050*srate)) ...
                      amp*rand(1, floor(0.150*srate)) ...
                      zeros(1, floor(0.050*srate)) ...
                      amp*rand(1, floor(0.150*srate)) ...
                      zeros(1, floor(0.050*srate)) ...
                      amp*rand(1, floor(0.150*srate)) ...
                      zeros(1, floor(0.100*srate)) ...
                      ];
        
        % Make sure the two components are same length:
        if length(partial_bb) < length(h_bb_unit)
            partial_bb = [partial_bb zeros(1, length(h_bb_unit)-length(partial_bb))];          
        elseif length(partial_bb) > length(h_bb_unit)
            partial_bb = partial_bb(1:length(h_bb_unit));
        end;
        
        harsher_badboy_sound.value = ...
            [ h_bb_unit+partial_bb h_bb_unit+partial_bb ];

        SoloParamHandle(obj, 'harsher_badboy_len', 'value', ...
            length(value(harsher_badboy_sound))/floor(srate));


        rpbox('loadrp3stereosound2', {[]; value(white_noise_sound)});
        if strcmp(BadBoySound, 'harsher')
            rpbox('loadrp3stereosound3', {[]; []; value(harsher_badboy_sound)});
        else
            rpbox('loadrp3stereosound3', {[]; []; value(badboy_sound)});
        end;

        SoloParamHandle(obj, 'RealTimeStates', 'value', struct(...
          'wait_for_cpoke', 0, ...  % Waiting for initial center poke
          'wait_for_apoke', 0, ...  % Waiting for an answer poke
          'leftover_sound', 0, ...  % poked out, waiting for sound to end
          'left_reward',    0, ...
          'right_reward',   0, ...
          'drink_time',     0, ...
          'left_dirdel',    0, ...  
          'right_dirdel',   0, ...
          'pre_chord',      0, ...
          'chord',          0, ...
          'timeout',        0, ...
          'iti',            0, ...
          'dead_time',      0, ...
          'state35',        0, ...
          'extra_iti',      0));

    case 'next_matrix',
      % Everything fine, skip init and proceed to next section of function

        
    otherwise,
        error(['Don''t know how to handle action ' action]);
end;

% toc,
if BadBoySoundChanged==1,
   if strcmp(BadBoySound, 'harsher')
      rpbox('loadrp3stereosound3', {[]; []; value(harsher_badboy_sound)});
   else
      rpbox('loadrp3stereosound3', {[]; []; value(badboy_sound)});
   end;
   BadBoySoundChanged.value = 0;
end;

switch side_list(n_done_trials+1),
  case 0,    stimulus_sound = SoundManager(obj, 'get_sound_id', 'Right1');
  case 0.25, stimulus_sound = SoundManager(obj, 'get_sound_id', 'Right2');
  case 1,    stimulus_sound = SoundManager(obj, 'get_sound_id', 'Left1');
  case 1.25, stimulus_sound = SoundManager(obj, 'get_sound_id', 'Left2');
end;

% stimulus_sound     = 1; % sample tone
white_noise_sound  = 2; % white noise sound
badboy_sound       = 4; % bad boy sound

all_sounds = [...
  SoundManager(obj, 'get_sound_id', 'Right1'), ...
  SoundManager(obj, 'get_sound_id', 'Right2'), ...
  SoundManager(obj, 'get_sound_id', 'Left1'),  ...
  SoundManager(obj, 'get_sound_id', 'Left2'),  ...
  white_noise_sound, ...
  badboy_sound ];

whln                   = value(white_noise_len);
white_noise_length     = value(white_noise_len);

if strcmp(BadBoySound, 'harsher') badboy_length = value(harsher_badboy_len);
else                              badboy_length = value(badboy_len);
end;


if ITILength/whln ~= floor(ITILength/whln)  |  ...
        TimeOutFirm/whln           ~= floor(TimeOutFirm/whln)  |  ...
        TimeOutLength/whln         ~= floor(TimeOutLength/whln)  |  ...
        ExtraITIonError/whln       ~= floor(ExtraITIonError/whln)  |  ...
        ITIReinitPenalty/whln      ~= floor(ITIReinitPenalty/whln)  |  ...
        TimeOutReinitPenalty/whln  ~= floor(TimeOutReinitPenalty/whln),
    error(sprintf('ITI, ExtraITI, Timeout, Reinit penalties must be multiples of %g',whln));
end;
if DeadTimeReinitPenalty/whln ~= floor(DeadTimeReinitPenalty/whln),
    error(sprintf(['DeadTimeReinit penalties must be multiples of %g\n ' ...
        'Correct this within @%s/%s'], whln, class(obj), mfilename));
end;

ExtraITIReinitPenalty = ITIReinitPenalty;

side = side_list(n_done_trials+1);
vpd  = vpd_list(n_done_trials+1);

vlst = ChordSection(obj, 'get_ValidSoundTime');
% toc,

sound_stay_time     = (chord_sound_len - go_dur) + vlst;
if sound_stay_time < 0.001, sound_stay_time = 0.001; end;

leftover_sound_time = chord_sound_len - sound_stay_time; 
if leftover_sound_time < 0.001, leftover_sound_time = 0.001; end; 


default_leds = (left1led*DefaultLeft1LED + center1led*DefaultCenter1LED + right1led*DefaultRight1LED);

sma = StateMachineAssembler('no_dead_time_technology', 'default_DOut', default_leds);


sma = add_scheduled_wave(sma, 'name', 'drinktime_in_dead_time_bell', ...
                         'preamble', 0.0005);

sma = add_scheduled_wave(sma, 'name', 'drink_time', ...
                         'preamble', DrinkTime+0.0001);
sma = add_scheduled_wave(sma, 'name', 'softdt',     ...
                         'preamble', SoftDT+0.0001);
switch side,
 case 0,
   sma = add_scheduled_wave(sma,'name','HighRT','preamble',HighWaterRT_R1);
   sma = add_scheduled_wave(sma,'name','LowRT', 'preamble',LowWaterRT_R1);
 case 0.25,
   sma = add_scheduled_wave(sma,'name','HighRT','preamble',HighWaterRT_R2);
   sma = add_scheduled_wave(sma,'name','LowRT', 'preamble',LowWaterRT_R2);
 case 1,
   sma = add_scheduled_wave(sma,'name','HighRT','preamble',HighWaterRT_L1);
   sma = add_scheduled_wave(sma,'name','LowRT', 'preamble',LowWaterRT_L1);
 case 1.25,
   sma = add_scheduled_wave(sma,'name','HighRT','preamble',HighWaterRT_L2);
   sma = add_scheduled_wave(sma,'name','LowRT', 'preamble',LowWaterRT_L2);
 otherwise,
   error(sprintf('What side is this??? %g \n', side));   
end;   


global fake_rp_box;
nix_dead_time_reinit = 0;


if nix_dead_time_reinit,
   start = get_current_iti_state(sma);   
   sma = add_state(sma, 'name', 'WAIT_FOR_DRINKTIME_BELL', ...
                   'iti_state',1, 'self_timer', 0.001, ...
                   'input_to_statechange', { ...
                     'Tup', 'current_state+1' ; ...
                     'drinktime_in_dead_time_bell_In',  ...
                     'deadtime_drinktime'     ; ...
                     'drinktime_in_dead_time_bell_Out', ...
                     'deadtime_drinktime',...
                     });
         
   sma = turn_sounds_off(sma, 'deadtime_init', all_sounds, 'iti_state', 1);
   sma = add_state(sma, 'iti_state', 1, ...
                   'self_timer', white_noise_length, ...
                   'output_actions', {'SoundOut', white_noise_sound}, ...
                   'input_to_statechange', {'Tup', 'state35'});
   stop = get_current_iti_state(sma)-1;
   RealTimeStates.dead_time = {start:stop 1};   

else
   start = get_current_iti_state(sma);
   sma = add_state(sma, 'name', 'WAIT_FOR_DRINKTIME_BELL', ...
                   'iti_state',1, 'self_timer', 0.001, ...
                   'input_to_statechange', { ...
                     'Tup', 'current_state+1' ; ...
                     'drinktime_in_dead_time_bell_In',  ...
                     'deadtime_drinktime'     ; ...
                     'drinktime_in_dead_time_bell_Out', ...
                     'deadtime_drinktime',...
                     });
         
   sma = noise_section2(sma, ...
                        'deadtime_init', 'deadtime_reinit', 'state35', ...
                        'off', 1, badboy_length, ...
                        badboy_sound*deadtime_noise, white_noise_length, ...
                        white_noise_sound*deadtime_noise,...
                        'iti_state', 1);

   sma = noise_section2(sma, ...
                        'deadtime_reinit',' deadtime_reinit', ...
                        'deadtime_init',...
                        BadBoySound, ...
                        round(DeadTimeReinitPenalty/white_noise_length), ...
                        badboy_length, badboy_sound*deadtime_noise, ...
                        white_noise_length, ...
                        white_noise_sound*deadtime_noise,...
                        'iti_state', 1);
   stop = get_current_iti_state(sma)-1;
   RealTimeStates.dead_time = {start:stop 1};   
end;



start = get_current_iti_state(sma);
sma = add_state(sma, 'name', 'DEADTIME_DRINKTIME', ...
                 'iti_state', 1, ...
                 'self_timer', 0.0001, ...
                 'input_to_statechange', {...
                   'Tup', 'deadtime_drinktime_in', ...
                 }, ...
                 'output_actions', {'SchedWaveTrig' 'drink_time'});

sma = add_state(sma, 'name', 'DEADTIME_DRINKTIME_IN', ...
                'iti_state', 1, ...
                'input_to_statechange', { ...
                  'drink_time_In',  'deadtime_softdt_in' ; ...
                  'Lout',           'deadtime_drinktime_out' ; ...
                  'Rout',           'deadtime_drinktime_out' ; ...
                   }); 
sma = add_state(sma, 'name', 'DEADTIME_DRINKTIME_OUT', ...
                'iti_state', 1, ...
                'input_to_statechange', { ...
                  'drink_time_In',  'deadtime_softdt_out' ; ...
                  'Lin',            'deadtime_drinktime_in' ; ...
                  'Rin',            'deadtime_drinktime_in' ; ...
                   }); 
sma = add_state(sma, 'name', 'DEADTIME_SOFTDT_IN', ...
                'iti_state', 1, ...
                'self_timer', DrinkTime, ...
                'input_to_statechange', { ...
                  'Tup',  'deadtime_iti'  ; ...
                  'Lout', 'deadtime_softdt_out'  ; ...
                  'Rout', 'deadtime_softdt_out'  ; ...
                   }, ...
                'output_actions', {'SchedWaveTrig', '-softdt'}); 
sma = add_state(sma, 'name', 'DEADTIME_SOFTDT_OUT', ...
                'iti_state', 1, ...
                'input_to_statechange', { ...
                  'softdt_In',  'deadtime_iti'  ; ...
                  'Lin',        'deadtime_softdt_in'  ; ...
                  'Rin',        'deadtime_softdt_in'  ; ...
                   }, ...
                'output_actions', {'SchedWaveTrig', 'softdt'}); 
stop = get_current_iti_state(sma)-1;
RealTimeStates.drink_time = {[start:stop] 1};


start = get_current_iti_state(sma);
sma = add_state(sma, 'name', 'DEADTIME_ITI', 'self_timer', 0.0001, ...
                'iti_state', 1, ...
                'default_statechange', 'current_state+1', ...
                'output_actions', {'SchedWaveTrig', '-HighRT-LowRT'});
if ITI_no_reinit_at_all, pokestate_name = 'current_state';
else                     pokestate_name = 'deadtime_itireinit';
end;
sma = noise_section2(sma, 'DEADTIME_ITI_b', pokestate_name, 'state35', ...
                     'off', ...
                     round(ITILength/white_noise_len), ...
                     badboy_length, badboy_sound, ...
                     white_noise_length, white_noise_sound, 'iti_state', 1);
if ITIReinit_NoBadBoy,
    sma = noise_section2(sma, 'DEADTIME_ITIREINIT', 'deadtime_itireinit', ...
                     'deadtime_iti', 'off', ...
                     round(ITIReinitPenalty/white_noise_len), ...
                     badboy_length, badboy_sound, ...
                     white_noise_length, white_noise_sound, 'iti_state', 1);
else
    sma = noise_section2(sma, 'DEADTIME_ITIREINIT', 'deadtime_itireinit', ...
                     'deadtime_iti', BadBoySound, ...
                     round(ITIReinitPenalty/white_noise_len), ...
                     badboy_length, badboy_sound, ...
                     white_noise_length, white_noise_sound, 'iti_state', 1);
end
stop = get_current_iti_state(sma)-1;
RealTimeStates.iti = {start:stop 1};



% toc,


RealTimeStates.state35 = 36;

% --- Now to work on MAIN, not iti, section ---

if n_done_trials >= TrialLimit  ||  ...
       (~isempty(protocol_start_time) && etime(clock, protocol_start_time) >= MaxMins*60),

   RealTimeStates.dead_time  =collect_states(RealTimeStates.dead_time, sma);
   RealTimeStates.drink_time =collect_states(RealTimeStates.drink_time, sma);
   RealTimeStates.iti        =collect_states(RealTimeStates.iti, sma);
   
   % We're done: loop forever with soft white noise sound
   
   rpbox('loadrp3stereosound2', {[]; 0.03*value(white_noise_sound)});
   start = get_current_state(sma);   
   sma = add_state(sma, 'self_timer', 0.03, ...
                   'input_to_statechange', {'Tup', 'current_state+1'});
   sma = add_state(sma, 'self_timer', white_noise_length, ...
                   'output_actions', {'SoundOut', white_noise_sound}, ...
                   'input_to_statechange', {'Tup' 'current_state-1'});
   stop  = get_current_state(sma)-1;   

   RealTimeStates.timeout   = start:stop;
   rpbox('send_statenames', RealTimeStates);
   push_history(RealTimeStates);

   send(sma, rpbox('getstatemachine'));
   SavingSection(obj, 'savesets', 'interactive', 0, 'commit', 1);
   SavingSection(obj, 'savedata', 'interactive', 0, 'commit', 1);
   warndlg('Saved data already-- no need to save again');
   return;
end;


% Ok-- we have neither exceeded the trial limit nor time limit. 


badboy_on_flag = ~strcmp(BadBoySound, 'off');




% ----

switch WaterDelivery,
    case 'only if nxt pke corr',
      post_tone_act = 'wait_for_apoke';
      if side>0.5, 
         right_poke_act_low_water  = 'extraiti'; 
         right_poke_act_reg_water  = 'extraiti'; 
         right_poke_act_high_water = 'extraiti'; 

         left_poke_act_low_water   = 'left_reward_low_water';
         left_poke_act_reg_water   = 'left_reward_reg_water';
         left_poke_act_high_water  = 'left_reward_high_water';
      else 
         left_poke_act_low_water   = 'extraiti'; 
         left_poke_act_reg_water   = 'extraiti'; 
         left_poke_act_high_water  = 'extraiti'; 

         right_poke_act_low_water  = 'right_reward_low_water';
         right_poke_act_reg_water  = 'right_reward_reg_water';
         right_poke_act_high_water = 'right_reward_high_water';
      end;
      
    case 'next corr poke',
      post_tone_act = 'wait_for_apoke';
      if     side>0.5, 
         right_poke_act_low_water  = 'minor_penalty'; 
         right_poke_act_reg_water  = 'minor_penalty'; 
         right_poke_act_high_water = 'minor_penalty'; 

         left_poke_act_low_water   = 'left_reward_low_water';
         left_poke_act_reg_water   = 'left_reward_reg_water';
         left_poke_act_high_water  = 'left_reward_high_water';
      else 
         left_poke_act_low_water   = 'minor_penalty'; 
         left_poke_act_reg_water   = 'minor_penalty'; 
         left_poke_act_high_water  = 'minor_penalty'; 

         right_poke_act_low_water  = 'right_reward_low_water';
         right_poke_act_reg_water  = 'right_reward_reg_water';
         right_poke_act_high_water = 'right_reward_high_water';
      end;
        
    case 'direct',
      if side>0.5, post_tone_act = 'left_direct_delivery';
      else         post_tone_act = 'right_direct_delivery';
      end;
      
 otherwise,
   error(['Don''t know how to do this WaterDelivery: ' WaterDelivery]);
end;

if strcmp(RewardPorts, 'both ports'),  
   % Override punishments, reward on both sides:
   post_tone_act  = 'wait_for_apoke';

   left_poke_act_low_water   = 'left_reward_low_water';
   left_poke_act_reg_water   = 'left_reward_reg_water';
   left_poke_act_high_water  = 'left_reward_high_water';
   right_poke_act_low_water  = 'right_reward_low_water';
   right_poke_act_reg_water  = 'right_reward_reg_water';
   right_poke_act_high_water = 'right_reward_high_water';
end;
% toc,

if strcmp(APokePenalty, 'on') wait_for_apoke_cin_action = 'timeout'; 
else                          wait_for_apoke_cin_action = 'current_state'; 
end;

sma = add_state(sma, 'name', 'WAIT_FOR_CPOKE', ...
                'output_actions', {'SoundOut', -stimulus_sound}, ...
                'input_to_statechange', {'Cin', 'current_state+1'});
% Only cpokes>10 ms count:
sma = add_state(sma, 'self_timer', 0.010, ...
                'input_to_statechange', { ...
                  'Tup'   'current_state+1' ; ...
                  'Cout'  'current_state-1'});
RealTimeStates.wait_for_cpoke = [0:1] + label2statenum(sma, 'wait_for_cpoke');


sma = legal_skipout(sma, 'start_Cin_with_skipout', 'timeout_firm', ...
                    sound_stay_time, LegalSkipOut/1000, stimulus_sound);


if LegalSkipOut==0,
   RealTimeStates.chord = label2statenum(sma, 'start_Cin_with_skipout');
else
   RealTimeStates.chord = ...
       label2statenum(sma, 'start_Cin_with_skipout') + (0:2);
end;
RealTimeStates.pre_chord = RealTimeStates.chord;



sma = add_scheduled_wave(sma, 'name', 'leftover_sound', ...
                         'preamble', leftover_sound_time);

if RespondDuringStim == 1,
  sma = add_state(sma, 'name', 'LEFTOVER_SOUND_LOW_WATER', ...
    'input_to_statechange', { ...
    'Cin',                wait_for_apoke_cin_action   ; ...
    'Lin',                left_poke_act_low_water     ; ...
    'Rin',                right_poke_act_low_water    ; ...
    'leftover_sound_In',  'wait_for_apoke_low_water'  ; ...
    'LowRT_In',           'leftover_sound_reg_water'  ; ...
    'HighRT_In',          'leftover_sound_high_water' ; ...
    }, ...
    'output_actions', { ...
    'SchedWaveTrig', 'LowRT+HighRT+leftover_sound' ; ...
    });

  sma = add_state(sma, 'name', 'LEFTOVER_SOUND_REG_WATER', ...
    'input_to_statechange', { ...
    'Cin',                wait_for_apoke_cin_action   ; ...
    'Lin',                left_poke_act_reg_water     ; ...
    'Rin',                right_poke_act_reg_water    ; ...
    'leftover_sound_In',  'wait_for_apoke_reg_water'  ; ...
    'HighRT_In',          'leftover_sound_high_water' ; ...
    });
  
  sma = add_state(sma, 'name', 'LEFTOVER_SOUND_HIGH_WATER', ...
    'input_to_statechange', { ...
    'Cin',                wait_for_apoke_cin_action   ; ...
    'Lin',                left_poke_act_high_water     ; ...
    'Rin',                right_poke_act_high_water    ; ...
    'leftover_sound_In',  'wait_for_apoke_high_water'  ; ...
    });
else
  sma = add_state(sma, 'name', 'LEFTOVER_SOUND_LOW_WATER', ...
    'input_to_statechange', { ...
    'Cin',                wait_for_apoke_cin_action   ; ...
    % 'Lin',                left_poke_act_low_water     ; ...
    % 'Rin',                right_poke_act_low_water    ; ...
    'leftover_sound_In',  'wait_for_apoke_low_water'  ; ...
    'LowRT_In',           'leftover_sound_reg_water'  ; ...
    'HighRT_In',          'leftover_sound_high_water' ; ...
    }, ...
    'output_actions', { ...
    'SchedWaveTrig', 'LowRT+HighRT+leftover_sound' ; ...
    });

  sma = add_state(sma, 'name', 'LEFTOVER_SOUND_REG_WATER', ...
    'input_to_statechange', { ...
    'Cin',                wait_for_apoke_cin_action   ; ...
    % 'Lin',                left_poke_act_reg_water     ; ...
    % 'Rin',                right_poke_act_reg_water    ; ...
    'leftover_sound_In',  'wait_for_apoke_reg_water'  ; ...
    'HighRT_In',          'leftover_sound_high_water' ; ...
    });
  
  sma = add_state(sma, 'name', 'LEFTOVER_SOUND_HIGH_WATER', ...
    'input_to_statechange', { ...
    'Cin',                wait_for_apoke_cin_action   ; ...
    % 'Lin',                left_poke_act_high_water     ; ...
    % 'Rin',                right_poke_act_high_water    ; ...
    'leftover_sound_In',  'wait_for_apoke_high_water'  ; ...
    });
  
end;


% Obsolete:
sma = add_state(sma, 'name', 'LEFTOVER_SOUND_IN_CENTER', ...
                'input_to_statechange', { ...
                  'leftover_sound_In',  'wait_for_apoke_in_center'  ; ...
                  'Cout',               'leftover_sound_low_water'  ; ...
                   }, ...
                   'output_actions', { ...
                     'SchedWaveTrig', 'leftover_sound' ; ...
                   });

% RealTimeStates.chord = [RealTimeStates.chord , ...
%                    label2statenum(sma, { ...
%                      'leftover_sound_low_water', ...
%                      'leftover_sound_reg_water', ...
%                      'leftover_sound_high_water'})];


% Obsolete next two states:
if strcmp(post_tone_act, 'wait_for_apoke'),
   sma = add_state(sma, 'name', 'WAIT_FOR_APOKE_IN_CENTER', ...
                   'input_to_statechange', { ...
                     'Cout',       'current_state+1'           ; ...
                     'Lin',        left_poke_act_low_water     ; ...
                     'Rin',        right_poke_act_low_water    ; ...
                   });
   sma = add_state(sma, 'self_timer', 0.0001, ...
                   'default_statechange', 'wait_for_apoke_low_water', ...
                   'output_actions', { ...
                     'SchedWaveTrig', 'LowRT+HighRT' ; ...
                   });
                     
   
   
   sma = add_state(sma, 'name', 'WAIT_FOR_APOKE_LOW_WATER', ...
                   'input_to_statechange', { ...
                     'Cin',        wait_for_apoke_cin_action   ; ...
                     'Lin',        left_poke_act_low_water     ; ...
                     'Rin',        right_poke_act_low_water    ; ...
                     'LowRT_In',  'wait_for_apoke_reg_water'  ; ...
                     'HighRT_In', 'wait_for_apoke_high_water' ; ...
                   });

   sma = add_state(sma, 'name', 'WAIT_FOR_APOKE_REG_WATER', ...
                   'input_to_statechange', { ...
                     'Cin',   wait_for_apoke_cin_action   ; ...
                     'Lin',   left_poke_act_reg_water     ; ...
                     'Rin',   right_poke_act_reg_water    ; ...
                     'HighRT_In', 'wait_for_apoke_high_water' ; ...
                   });

   sma = add_state(sma, 'name', 'WAIT_FOR_APOKE_HIGH_WATER', ...
                   'input_to_statechange', { ...
                     'Cin',   wait_for_apoke_cin_action   ; ...
                     'Lin',   left_poke_act_high_water     ; ...
                     'Rin',   right_poke_act_high_water    ; ...
                   });
      
   
   
elseif strcmp(post_tone_act, 'left_direct_delivery'),
   sma = add_state(sma, 'default_statechange', 'left_direct_delivery', ...
                   'self_timer', leftover_sound_time, ...
                   'input_to_statechange', { ...
                     'Cin',  'current_state'   ; ...
                     'Cout', 'current_state'   ; ...
                     });
elseif strcmp(post_tone_act, 'right_direct_delivery'),
   sma = add_state(sma, 'default_statechange', 'right_direct_delivery', ...
                   'self_timer', leftover_sound_time, ...
                   'input_to_statechange', { ...
                     'Cin',  'current_state'   ; ...
                     'Cout', 'current_state'   ; ...
                     });
else
   error('what''s this weird post_tone_act??');
end;




global left1water;  lvid = left1water; 
global right1water; rvid = right1water;


% What to do with sounds on entering reward state (not dir del):
if ReplayRelevant==1, reward_sound_out = stimulus_sound;
else 
   if OffRelevant, reward_sound_out = -stimulus_sound;
   else            reward_sound_out = 0;
   end;
end;

sma = add_state(sma, 'name', 'LEFT_REWARD_LOW_WATER', ...
                'output_actions', { ...
                  'SoundOut', reward_sound_out   ; ...
                  'DOut',     left1water+default_leds         ; ...
                   }, ...
                'self_timer', LeftWValve*LowWaterFactor, ...
                'input_to_statechange', {'Tup', 'drinktime'});

sma = add_state(sma, 'name', 'LEFT_REWARD_REG_WATER', ...
                'output_actions', { ...
                  'SoundOut', reward_sound_out   ; ...
                  'DOut',     left1water+default_leds         ; ...
                   }, ...
                'self_timer', LeftWValve, ...
                'input_to_statechange', {'Tup', 'drinktime'});

sma = add_state(sma, 'name', 'LEFT_REWARD_HIGH_WATER', ...
                'output_actions', { ...
                  'SoundOut', reward_sound_out   ; ...
                  'DOut',     left1water+default_leds         ; ...
                   }, ...
                'self_timer', LeftWValve*HighWaterFactor, ...
                'input_to_statechange', {'Tup', 'drinktime'});



sma = add_state(sma, 'name', 'RIGHT_REWARD_LOW_WATER', ...
                'output_actions', { ...
                  'SoundOut', reward_sound_out   ; ...
                  'DOut',     right1water+default_leds         ; ...
                   }, ...
                'self_timer', RightWValve*LowWaterFactor, ...
                'input_to_statechange', {'Tup', 'drinktime'});

sma = add_state(sma, 'name', 'RIGHT_REWARD_REG_WATER', ...
                'output_actions', { ...
                  'SoundOut', reward_sound_out   ; ...
                  'DOut',     right1water+default_leds         ; ...
                   }, ...
                'self_timer', RightWValve, ...
                'input_to_statechange', {'Tup', 'drinktime'});

sma = add_state(sma, 'name', 'RIGHT_REWARD_HIGH_WATER', ...
                'output_actions', { ...
                  'SoundOut', reward_sound_out   ; ...
                  'DOut',     right1water+default_leds         ; ...
                   }, ...
                'self_timer', RightWValve*HighWaterFactor, ...
                'input_to_statechange', {'Tup', 'drinktime'});



sma = add_state(sma, 'name', 'LEFT_DIRECT_DELIVERY', ...
                'output_actions', {'DOut', left1water+default_leds}, ...
                'self_timer', LeftWValve, ...
                'input_to_statechange', {'Tup', 'current_state+1'});
sma = add_state(sma, ...
                'input_to_statechange', {'Lin', 'drinktime'});


sma = add_state(sma, 'name', 'RIGHT_DIRECT_DELIVERY', ...
                'output_actions', {'DOut', right1water+default_leds}, ...
                'self_timer', RightWValve, ...
                'input_to_statechange', {'Tup', 'current_state+1'});
sma = add_state(sma, ...
                'input_to_statechange', {'Rin', 'drinktime'});


if drinktime_in_dead_time,
   % If drinktime is going to be in deadtime, go straight to ITI
   sma = add_state(sma, 'name', 'DRINKTIME', ...
                   'self_timer', 0.0001, ...
                   'default_statechange', 'iti');
   RealTimeStates.drink_time = [RealTimeStates.drink_time  ;  ...
                       {label2statenum(sma, 'drinktime') 0}];
else
   start = get_current_state(sma);
   sma = add_state(sma, 'name', 'DRINKTIME', ...
                   'self_timer', 0.0001, ...
                   'input_to_statechange', {...
                     'Tup', 'drinktime_in', ...
                   }, ...
                   'output_actions', {'SchedWaveTrig' 'drink_time'}); 

   sma = add_state(sma, 'name', 'DRINKTIME_IN', ...
                   'input_to_statechange', { ...
                     'drink_time_In',  'softdt_in' ; ...
                     'Lout',           'drinktime_out' ; ...
                     'Rout',           'drinktime_out' ; ...
                   }); 
   sma = add_state(sma, 'name', 'DRINKTIME_OUT', ...
                   'input_to_statechange', { ...
                     'drink_time_In',  'softdt_out' ; ...
                     'Lin',            'drinktime_in' ; ...
                     'Rin',            'drinktime_in' ; ...
                   }); 
   sma = add_state(sma, 'name', 'SOFTDT_IN', ...
                   'self_timer', DrinkTime, ...
                   'input_to_statechange', { ...
                     'Tup',  'iti'  ; ...
                     'Lout', 'softdt_out'  ; ...
                     'Rout', 'softdt_out'  ; ...
                   }, ...
                   'output_actions', {'SchedWaveTrig', '-softdt'}); 
   sma = add_state(sma, 'name', 'SOFTDT_OUT', ...
                   'input_to_statechange', { ...
                     'softdt_In',  'iti'  ; ...
                     'Lin',        'softdt_in'  ; ...
                     'Rin',        'softdt_in'  ; ...
                   }, ...
                   'output_actions', {'SchedWaveTrig', 'softdt'}); 
   stop = get_current_state(sma)-1;
   RealTimeStates.drink_time = [RealTimeStates.drink_time  ;  ...
                       {start:stop 0}];
end;   

RealTimeStates.leftover_sound= label2statenum(sma, { ...
  'leftover_sound_low_water' , ...
  'leftover_sound_reg_water' , ...
  'leftover_sound_high_water', ....
  'leftover_sound_in_center'});
RealTimeStates.wait_for_apoke= label2statenum(sma, { ...
  'wait_for_apoke_in_center' , ...
  'wait_for_apoke_low_water' , ...
  'wait_for_apoke_reg_water' , ...
  'wait_for_apoke_high_water'});
RealTimeStates.left_reward    = label2statenum(sma, { ...
  'left_reward_low_water', ...
  'left_reward_reg_water', ...
  'left_reward_high_water'});
RealTimeStates.right_reward    = label2statenum(sma, { ...
  'right_reward_low_water', ...
  'right_reward_reg_water', ...
  'right_reward_high_water'});
RealTimeStates.left_dirdel   = label2statenum(sma, 'left_direct_delivery');
RealTimeStates.right_dirdel  = label2statenum(sma, 'right_direct_delivery');


% --------

start = get_current_state(sma);
if drinktime_in_dead_time,
   % if drinktime (and iti) are in dead time, turn on bell flag and go
   % straight to state 35 
   sma = add_state(sma, 'name', 'ITI', 'self_timer', 0.0001, ...
                   'default_statechange', 'current_state+1', ...
                   'output_actions', { ...
                     'SchedWaveTrig', '-HighRT-LowRT' ...
                   });
   sma = add_state(sma, 'self_timer', 0.0001, ...
                   'default_statechange', 'state35', ...
                   'output_actions', { ...
                     'SchedWaveTrig', 'drinktime_in_dead_time_bell' ...
                   });

   % For no drinktime, when coming from extra_iti:
   sma = add_state(sma, 'name', 'ITI_no_drinktime', 'self_timer', 0.0001,...
                   'default_statechange', 'state35', ...
                   'output_actions', { ...
                     'SchedWaveTrig', '-HighRT-LowRT' ...
                   });
   
else
   sma = add_state(sma, 'name', 'ITI', 'self_timer', 0.0001, ...
                   'default_statechange', 'ITI_b', ...
                   'output_actions', {'SchedWaveTrig', '-HighRT-LowRT'});
   sma = add_state(sma, 'name', 'ITI_no_drinktime', 'self_timer', 0.0001,...
                   'default_statechange', 'ITI_b', ...
                   'output_actions', {'SchedWaveTrig', '-HighRT-LowRT'});
end;
if ITI_no_reinit_at_all, pokestate_name = 'current_state';
else                     pokestate_name = 'itireinit';
end;
sma = noise_section2(sma, 'ITI_b', pokestate_name, 'state35', 'off', ...
                     round(ITILength/white_noise_len), ...
                     badboy_length, badboy_sound, ...
                     white_noise_length, white_noise_sound);
if ITIReinit_NoBadBoy
   sma = noise_section2(sma, 'ITIREINIT', 'itireinit', 'iti',...
                        'off', ...
                        round(ITIReinitPenalty/white_noise_len),...
                        badboy_length, badboy_sound, ...
                        white_noise_length, white_noise_sound);
else
   sma = noise_section2(sma, 'ITIREINIT', 'itireinit', 'iti',...
                        BadBoySound, ...
                        round(ITIReinitPenalty/white_noise_len),...
                        badboy_length, badboy_sound, ...
                        white_noise_length, white_noise_sound);
end;   
stop = get_current_state(sma)-1;
RealTimeStates.iti = [RealTimeStates.iti ; {start:stop 0}];



start = get_current_state(sma);
sma = noise_section2(sma, 'EXTRAITI', 'extraiti_reinit', ...
                     'iti_no_drinktime',...
                     BadBoySound, round(ExtraITIonError/white_noise_len), ...
                     badboy_length, badboy_sound, ...
                     white_noise_length, white_noise_sound, ...
                     'off_relevant', OffRelevant);

if ExtraITIonError == 0, donestate = 'iti_no_drinktime';
else                     donestate = 'extraiti_postBadBoy';
end;
sma = noise_section2(sma, 'EXTRAITI_REINIT', 'extraiti_reinit', donestate, ...
                     BadBoySound, ...
                     round(ExtraITIReinitPenalty/white_noise_len), ...
                     badboy_length, badboy_sound, ...
                     white_noise_length, white_noise_sound, ...
                     'off_relevant', OffRelevant);
stop = get_current_state(sma)-1;
RealTimeStates.extra_iti = start:stop;



% Now TimeOutFirm:  -----
start = get_current_state(sma);
sma = add_state(sma, 'name', 'TIMEOUT_FIRM', ...
                'self_timer', 0.0001, ...
                'output_actions', {'SoundOut', -stimulus_sound}, ...
                'default_statechange', 'current_state+1');
for i=1:round(TimeOutFirm/white_noise_len),
   sma = add_state(sma, 'self_timer', white_noise_length, ...
                   'output_actions', {'SoundOut', white_noise_sound}, ...
                   'input_to_statechange', {'Tup', 'current_state+1'});
end;
sma = add_state(sma, 'self_timer', 0.0001, ...
                'output_actions', {'SoundOut', -white_noise_sound}, ...
                'default_statechange', 'current_state+1');
if TimeOutLength-TimeOutFirm < 0.001 & round(TimeOutFirm/white_noise_len)>0, 
   sma = add_state(sma, 'self_timer', 0.0001, ...
                   'default_statechange', 'wait_for_cpoke');
end;
% End TimeOutFirm ---


sma = noise_section2(sma, 'TIMEOUT', 'timeout_reinit', 'wait_for_cpoke', ...
                     'off', ...
                     round(TimeOutLength-TimeOutFirm/white_noise_len), ...
                     badboy_length, badboy_sound, ...
                     white_noise_length, white_noise_sound);
if TimeOutLength == 0, donestate = 'wait_for_cpoke';
else                   donestate = 'timeout_postBadBoy';
end;
sma = noise_section2(sma, 'TIMEOUT_REINIT', 'timeout_reinit', donestate, ...
                     BadBoySound, ...
                     round(TimeOutReinitPenalty/white_noise_len), ...
                     badboy_length, badboy_sound, ...
                     white_noise_length, white_noise_sound);
stop = get_current_state(sma)-1;
RealTimeStates.timeout = start:stop;



start = get_current_state(sma);
sma = add_state(sma, 'name', 'MINOR_PENALTY', 'self_timer', 0.0001, ...
                'default_statechange', 'current_state+1', ...
                'output_actions', {'SoundOut', -white_noise_sound});
for i=1:round(MinorPenalty/white_noise_len),
   sma = add_state(sma, 'self_timer', white_noise_length, ...
                   'output_actions', {'SoundOut', white_noise_sound}, ...
                   'input_to_statechange', {'Tup', 'current_state+1'});
   sma = add_state(sma, 'self_timer', 0.0001, ...
                   'default_statechange', 'current_state+1', ...
                   'output_actions', {'SoundOut', -white_noise_sound});
end;
sma = add_state(sma, 'self_timer', 0.0001, ...
                'default_statechange', 'wait_for_apoke_reg_water');
stop = get_current_state(sma)-1;
RealTimeStates.extra_iti = [RealTimeStates.extra_iti start:stop];


RealTimeStates.dead_time  = collect_states(RealTimeStates.dead_time, sma);
RealTimeStates.drink_time = collect_states(RealTimeStates.drink_time, sma);
RealTimeStates.iti        = collect_states(RealTimeStates.iti, sma);



Stateguys.ITI            = label2statenum(sma, 'iti');
Stateguys.ITIReinit      = label2statenum(sma, 'itireinit');
Stateguys.ExtraITI       = label2statenum(sma, 'extraiti');
Stateguys.ExtraITIReinit = label2statenum(sma, 'extraiti_reinit');
Stateguys.TimeOutFirm    = label2statenum(sma, 'timeout_firm');
Stateguys.TimeOut        = label2statenum(sma, 'timeout');
Stateguys.TimeOutReinit  = label2statenum(sma, 'timeout_reinit');


% store for posterity
if ~exist('state_matrix', 'var'),
    SoloParamHandle(obj, 'state_matrix');
end;
state_matrix.value = sma;

if ~exist('assembler', 'var'),
    SoloParamHandle(obj, 'assembler');
end;
assembler.value = only_labels_and_outcols(sma);
push_history(assembler);

% toc,

% toc,
if n_done_trials==0, send(sma, rpbox('getstatemachine'), 'run_trial_asap', 0);
else                 send(sma, rpbox('getstatemachine'));
end;
% toc,
rpbox('send_statenames', RealTimeStates);
% toc,

% Store the latest RealTimeStates
push_history(RealTimeStates);
% toc,

return;

%
% --------- [sma] = turn_sounds_off(sma, startstate_name, soundlist, varargin)
%
%
 
function [sma] = turn_sounds_off(sma, startstate_name, soundlist, varargin)
   pairs = { ...
     'iti_state'   0  ; ...
   }; parseargs(varargin, pairs);

   
   if ~isempty(soundlist),
      sma = add_state(sma, 'name', startstate_name, ...
                      'iti_state', iti_state, ...                      
                      'self_timer', 0.0001, ...
                      'output_actions', {'SoundOut', -soundlist(1)}, ...
                      'input_to_statechange', {'Tup', 'current_state+1'});
   end;
   
   for i=2:length(soundlist),
      sma = add_state(sma, ...
                      'iti_state', iti_state, ...
                      'self_timer', 0.0001, ...
                      'output_actions', {'SoundOut', -soundlist(i)}, ...
                      'input_to_statechange', {'Tup', 'current_state+1'});
   end;
   return;

   
%
%
% --------- noise_section2
%
%
   
function [sma] = noise_section2(sma, startstate_name, pokestate_name, ...
                                donestate_name, BadBoySound, ...
                                n_wh_noise, ...
                                badboy_length, badboy_sound, ...
                                white_noise_length, white_noise_sound, ...
                                varargin)   
   pairs = { ...
     'off_relevant'    1   ; ...
     'iti_state'       0   ; ...
   }; parseargs(varargin, pairs);

   all_sounds = [...
     SoundManager(quadsamp3obj, 'get_sound_id', 'Right1'), ...
     SoundManager(quadsamp3obj, 'get_sound_id', 'Right2'), ...
     SoundManager(quadsamp3obj, 'get_sound_id', 'Left1'),  ...
     SoundManager(quadsamp3obj, 'get_sound_id', 'Left2'),  ...
     white_noise_sound, ...
     badboy_sound ];

   % First turn all sounds off:
   if off_relevant,
      sma = turn_sounds_off(sma, startstate_name, all_sounds, ...
                            'iti_state', iti_state);
   else
      sma = turn_sounds_off(sma, startstate_name, [white_noise_sound badboy_sound], ...
                            'iti_state', iti_state);
   end;

   if ~strcmp(BadBoySound, 'off')
    % Start with bad boy sound
    sma = add_state(sma, 'iti_state', iti_state, ...
                    'self_timer', badboy_length, ...
                    'output_actions', {'SoundOut', badboy_sound}, ...
                    'input_to_statechange', { ...
                      'Tup', 'current_state+1'  ; ...
                      'Cin', pokestate_name     ; ...
                      'Lin', pokestate_name     ; ...
                      'Rin', pokestate_name     ; ...
                   });
   end;

   
   sma = add_state(sma, 'iti_state', iti_state, ...
                   'name', [startstate_name '_postBadBoy'], ...
                   'self_timer', 0.0001, ...
                   'default_statechange', 'current_state+1');
      
   % Now white noises
   for i=1:n_wh_noise,
      sma = add_state(sma, 'iti_state', iti_state, ...
                      'self_timer', white_noise_length, ...
                      'output_actions', {'SoundOut', white_noise_sound}, ...
                      'input_to_statechange', { ...
                        'Tup', 'current_state+1'  ; ...
                        'Cin', pokestate_name     ; ...
                        'Lin', pokestate_name     ; ...
                        'Rin', pokestate_name     ; ...
                     });
   end;
   
   % We're done; go to your donestate.
   sma = add_state(sma, 'iti_state', iti_state, ...
                   'self_timer', 0.0001, 'default_statechange',donestate_name);

   return;

   
   
   
% 
%  ----- LEGAL SKIPOUT --------------------
%

function [sma] = legal_skipout(sma, startstate_name, penaltystate_name, ...
                               timelength, legalskiplen, initial_sound)

   if nargin < 6, initial_sound = 0; end;

   if legalskiplen==0,
      sma = add_state(sma, 'name', startstate_name, ...
                      'default_statechange', penaltystate_name, ...
                      'output_actions', {'SoundOut', initial_sound}, ...
                      'self_timer', timelength, ...
                      'input_to_statechange', {'Tup', 'current_state+1'});
      return;
   end;
   
   [sma, skipname]  = add_scheduled_wave(sma, 'preamble', legalskiplen);
   [sma, totalname] = add_scheduled_wave(sma, 'preamble', timelength);

   sma = add_state(sma, 'name', startstate_name, ...
                   'output_actions', { ...
                     'SoundOut',      initial_sound  ; ...
                     'SchedWaveTrig'  totalname      ; ...
                     }, ...
                   'self_timer', 0.0001, ...
                   'input_to_statechange', {'Tup', 'current_state+1'});
   sma = add_state(sma, ...
                   'output_actions', {'SchedWaveTrig', ['-' skipname]}, ...
                   'input_to_statechange', { ...
                     'Cout',            'current_state+1' ; ...
                     [totalname '_In'], 'current_state+2' ; ...
                   });
   sma = add_state(sma, ...
                   'output_actions', {'SchedWaveTrig', skipname}, ...
                   'input_to_statechange', { ...
                     'Cin',             'current_state-1' ; ...
                     [skipname  '_In'], penaltystate_name ; ...
                     [totalname '_In'], 'current_state+1' ; ...
                   });
   return;
   

   
% ------------ COLLECT_STATES  -----


function [s] = collect_states(states, sma)
   
   s = [];
   
   for i=1:rows(states),
      if states{i,2} == 1,
         s = [s states{i,1} + get_first_iti_state(sma)];
      else
         s = [s states{i,1}];
      end;
   end;