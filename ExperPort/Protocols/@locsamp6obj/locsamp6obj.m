function [obj] = locsamp6obj(a)
    
% -------- BEGIN Magic code that all protocol objects must have ---
% Default object:
obj = struct('empty', []);
obj = class(obj, mfilename);

% If creating an empty object, return without further ado:
if nargin==1 && strcmp(a, 'empty'), return; end;

delete_sphandle('owner', mfilename); % Delete previous vars owned by this object

% Non-empty: proceed with regular init of this object
if nargin==1 && isstr(a), 
    SoloParamHandle(obj, 'protocol_name', 'value', lower(a)); 
end;

% Make default figure. Remember to make it non-saveable; on next run
% the handle to this figure might be different, and we don't want to
% overwrite it when someone does load_data and some old value of the
% fig handle was stored there...
SoloParamHandle(obj, 'myfig', 'saveable', 0); myfig.value = figure;
SoloFunction('close', 'ro_args', 'myfig');
set(value(myfig), ...
    'Name', value(protocol_name), 'Tag', value(protocol_name), ...
    'closerequestfcn', ['ModuleClose(''' value(protocol_name) ''')'], ...
    'NumberTitle', 'off', 'MenuBar', 'none');

% -------- END Magic code that all protocol objects must have ---


set(value(myfig), 'Position', [440 29 559 705])

SoloParamHandle(obj, 'n_done_trials',    'value', 0);
SoloParamHandle(obj, 'n_started_trials', 'value', 0);
SoloParamHandle(obj, 'maxtrials',        'value', 1000);
SoloParamHandle(obj, 'hit_history',      'value', NaN*ones(1, value(maxtrials)));

x = 1; y = 1;                     % Position on GUI
[x, y] =                          InitSaving(x, y);       next_row(y);
[x, y, RightWValve, LeftWValve] = InitWaterValves(x, y);  next_row(y);

SoloFunction('SidesSection', 'ro_args', ...
    {'n_done_trials', 'n_started_trials', 'hit_history','maxtrials'});
[x, y, side_list, WaterDelivery, RewardPorts] = ...
    SidesSection(obj, 'init', x, y); next_row(y, 0.5);         
% side_list is a vector of correct sides, one per trial.

next_column(x); y = 1;
SoloFunction('ChordSection', ...
             'ro_args', {'side_list', 'n_done_trials', 'n_started_trials'});
[x, y, chord_sound_len] = ChordSection(obj, 'init', x, y); next_row(y, 0.5);

SoloFunction('VpdsSection', 'ro_args', ...
    {'n_done_trials', 'n_started_trials', 'maxtrials', 'chord_sound_len'});
[x, y, vpd_list] = VpdsSection(obj, 'init', x, y);         next_row(y, 0.5);
% vpd_list is a vector of valid center poke durations, one per trial.

[x, y, BadBoySound, ITISound, ITILength, ITIReinitPenalty, ...
 TimeOutSound, TimeOutLength, TimeOutReinitPenalty, ...
 APokePenalty,  ...
 ExtraITIonError, DrinkTime] = ...
  TimesSection(obj, 'init', x, y);                         next_row(y, 1);

SoloParamHandle(obj, 'RealTimeStates', 'value', struct(...
  'wait_for_cpoke', 0, ...  % Waiting for initial center poke
  'wait_for_apoke', 0, ...  % Waiting for an answer poke
  'left_reward',    0, ...
  'right_reward',   0, ...
  'drink_time',     0, ...
  'left_dirdel',    0, ...  
  'right_dirdel',   0, ...
  'pre_chord',      0, ...
  'chord',          0, ...
  'timeout',        0, ...
  'iti',            0, ...
  'dead_time',      0, ...
  'state35',        0, ...
  'extra_iti',      0));
SoloParamHandle(obj, 'LastTrialEvents', 'value', []);

next_column(x); y = 1;
SoloFunction('RewardsSection', ...
             'rw_args', {'LastTrialEvents', 'hit_history'}, ...
             'ro_args', {'RealTimeStates', 'side_list', 'n_done_trials', ...
                    'n_started_trials'});
[x, y] = RewardsSection(obj, 'init', x, y);
SoloFunction('PokeMeasuresSection', 'rw_args', 'LastTrialEvents', ...
    'ro_args', {'n_done_trials', 'n_started_trials', 'RealTimeStates'});
[x, y] = PokeMeasuresSection(obj, 'init', x, y);


% --- Making and uploading the state matrix
SoloFunction('make_and_upload_state_matrix', ...
    'rw_args', 'RealTimeStates', ...
    'ro_args', {'n_done_trials', 'side_list', 'vpd_list', ...
    'chord_sound_len', 'WaterDelivery', 'RewardPorts', 'DrinkTime', ...
    'BadBoySound', 'ITISound', 'ITILength', 'ITIReinitPenalty', ...
    'TimeOutSound', 'TimeOutLength', 'TimeOutReinitPenalty', ...
    'APokePenalty', ...
    'ExtraITIonError', 'LeftWValve', 'RightWValve'});

make_and_upload_state_matrix(obj, 'init');
push_history(class(obj));
n_started_trials.value = 1;

% ------------------------------------------------------------------
% List of functions to call, in sequence, when a trial is finished:
% If adding a function to this list,
%    (a) Declare its args with a SoloFunction() call
%    (b) Add your function as a method of the current object
%    (c) As the first action of your method, call GetSoloFunctionArgs;
%
SoloParamHandle(obj, 'trial_finished_actions', 'value', { ...
  'RewardsSection(obj, ''update'');'                     ; ...
  'SidesSection(obj, ''choose_next_side'');'             ; ...
  'SidesSection(obj, ''update_plot'');'                  ; ... 
  'VpdsSection(obj,  ''update_plot'');'                  ; ...
  'ChordSection(obj, ''make'');'                         ; ... 
  'ChordSection(obj, ''upload'');'                       ; ...
  'make_and_upload_state_matrix(obj, ''next_matrix'');'  ; ... 
  'CurrentTrialPokesSubsection(obj, ''redraw'')'         ; ...
  'push_history(class(obj));'                            ; ... % no args
});
SoloFunction('state35', 'rw_args', {'n_done_trials', 'n_started_trials'}, ...
    'ro_args', 'trial_finished_actions');


% List of functions to call, in sequence, when an update call is made:
SoloParamHandle(obj, 'within_trial_update_actions', 'value', { ...
    'PokeMeasuresSection(obj, ''update_counts'');'  ; ...
    });
SoloFunction('update', 'ro_args', 'within_trial_update_actions');

% ------------------------------------------------------------------

return;


